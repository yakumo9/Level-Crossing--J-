#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>

//警報灯の出力ピン
#define	PORT_FLASHLIGHT_L	PORTB
#define	PIN_FLASHLIGHT_L	PB0
#define	PORT_FLASHLIGHT_R	PORTD
#define	PIN_FLASHLIGHT_R	PD7

//  波形の分割数 = AVR動作クロック ÷ 256(キャリヤ周波数) ÷ 256(PWMの分解能)
//  [122 = 8,000,000Hz / 256 /256]
//	波形インデックス加算値 = 発生周波数 × 256(16bitの上位8bitを使用) ÷ 波形の分割数
//const	int stepOfWave1	= 1444;	//	= 688 Hz * 256/122
//const	int stepOfWave2	= 1542;	//	= 735 Hz * 256/122
const	int stepOfWave1	= 1466;	//	= 699 Hz * 256/122
const	int stepOfWave2	= 1557;	//	= 742 Hz * 256/122


//振幅0xffの360度分のサインテーブル(分解能256)
const uint8_t sin_table[] PROGMEM = {
	0x7f,0x82,0x85,0x88,0x8b,0x8f,0x92,0x95,
	0x98,0x9b,0x9e,0xa1,0xa4,0xa7,0xaa,0xad,
	0xb0,0xb2,0xb5,0xb8,0xbb,0xbe,0xc0,0xc3,
	0xc6,0xc8,0xcb,0xcd,0xd0,0xd2,0xd4,0xd7,
	0xd9,0xdb,0xdd,0xdf,0xe1,0xe3,0xe5,0xe7,
	0xe9,0xea,0xec,0xee,0xef,0xf0,0xf2,0xf3,
	0xf4,0xf5,0xf7,0xf8,0xf9,0xf9,0xfa,0xfb,
	0xfc,0xfc,0xfd,0xfd,0xfd,0xfe,0xfe,0xfe,
	0xfe,0xfe,0xfe,0xfe,0xfd,0xfd,0xfd,0xfc,
	0xfc,0xfb,0xfa,0xf9,0xf9,0xf8,0xf7,0xf5,
	0xf4,0xf3,0xf2,0xf0,0xef,0xee,0xec,0xea,
	0xe9,0xe7,0xe5,0xe3,0xe1,0xdf,0xdd,0xdb,
	0xd9,0xd7,0xd4,0xd2,0xd0,0xcd,0xcb,0xc8,
	0xc6,0xc3,0xc0,0xbe,0xbb,0xb8,0xb5,0xb2,
	0xb0,0xad,0xaa,0xa7,0xa4,0xa1,0x9e,0x9b,
	0x98,0x95,0x92,0x8f,0x8b,0x88,0x85,0x82,
	0x7f,0x7c,0x79,0x76,0x73,0x6f,0x6c,0x69,
	0x66,0x63,0x60,0x5d,0x5a,0x57,0x54,0x51,
	0x4e,0x4c,0x49,0x46,0x43,0x40,0x3e,0x3b,
	0x38,0x36,0x33,0x31,0x2e,0x2c,0x2a,0x27,
	0x25,0x23,0x21,0x1f,0x1d,0x1b,0x19,0x17,
	0x15,0x14,0x12,0x10,0x0f,0x0e,0x0c,0x0b,
	0x0a,0x09,0x07,0x06,0x05,0x05,0x04,0x03,
	0x02,0x02,0x01,0x01,0x01,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,
	0x02,0x03,0x04,0x05,0x05,0x06,0x07,0x09,
	0x0a,0x0b,0x0c,0x0e,0x0f,0x10,0x12,0x14,
	0x15,0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,
	0x25,0x27,0x2a,0x2c,0x2e,0x31,0x33,0x36,
	0x38,0x3b,0x3e,0x40,0x43,0x46,0x49,0x4c,
	0x4e,0x51,0x54,0x57,0x5a,0x5d,0x60,0x63,
	0x66,0x69,0x6c,0x6f,0x73,0x76,0x79,0x7c
};

//スピーカーボリューム，アタック音／余韻に使う
volatile	unsigned char	Volume;
volatile	unsigned char	DirVolume;

//関数宣言
int suspend( void );

//タイマー2オーバーフロー割込み
ISR(TIMER2_OVF_vect)
{
	//波形のインデクス値
	static unsigned int 	IndexOfWave1;
	static unsigned int		IndexOfWave2;
	
	//
	static unsigned int		AlarmVolume;
	unsigned char			AlarmVolumeChar;
	
	//波形データ
	unsigned int wav1;
	unsigned int wav2;
	
	//波形を作る
	wav1	= pgm_read_byte( &sin_table[(IndexOfWave1 >> 8)] );	//
	wav2	= pgm_read_byte( &sin_table[(IndexOfWave2 >> 8)] );	//
	wav1	= wav1 >> 1	;//
	
	//アラーム音の立ち上がり/余韻を作る
	if(DirVolume == 1)
	{
		AlarmVolume	+= 128;
		if(AlarmVolume > 32767) 
		{
			AlarmVolume	= 32767;
			DirVolume	= 0;
		}
	}
	else
	{
		if(AlarmVolume > 6144)
			AlarmVolume	-= 4;
		
	}
	
	AlarmVolumeChar = AlarmVolume >> 7;
	//2つの波形を加算して(桁が一つ多くなるのでシフトする)カウンタへ入れる。
	OCR2B	= (((wav1 + wav2) >> 1) * AlarmVolumeChar) >> 8;
	
	IndexOfWave1 += stepOfWave1;
	IndexOfWave2 += stepOfWave2;
}

//タイマー0オーバーフロー割込み
//ISR(TIMER0_OVF_vect)
//{
//}

void delay_ms( int time )
{
	// 指定ms分ループ
	while( time-- ){
		_delay_ms( 1 );
	}
}

int main( void )
{
	unsigned int	i	= 0, j	= 0,k	= 0;
	unsigned int	timeOfClose	= 0;
	
	Volume = 0;
	
	// Timer2設定
	DDRB	= 0b00000001;	// PB0(警報灯1)を出力に設定
	PORTB	= 0x00;	// ポートBをLowに初期化
	
	DDRD	= 0b11101000;	// PD7(警報灯2),PD6(遮断機降下),PD5(遮断機上昇),PD3(OC2B)を出力に設定
	PORTD	= 0x01;	// ポートDをLowに初期化,PD0プルアップ
	
	TCCR2A	= 0b00100011;	// 8bit高速PWM動作 比較A出力選択でOC2Bへの非反転動作
	TCCR2B	= 0b00000001;	// タイマ/カウンタ2入力クロック前置分周なし
	TIMSK2	|= (1 << TOIE2);  /* Timer2 overflow int enable */
	
	//Timer0設定
	//TCCR0A	= 0b10000011;	// 8bit高速PWM動作 比較A出力選択でOC0Bへの非反転動作
	//TCCR0B	= 0b00000001;	// クロック前置分周なし
	//TCNT0	= 0;
	//TIMSK0	|= (1 << TOIE0);  /* Timer0 overflow int enable */
	
	//OCR0A	= 0;
	sei() ;			//割り込みを許可

	DirVolume	= 1;
	while(1){
		
		//警報機の鳴動を止める
		if((PIND & 0x01)== 0)
		{
			timeOfClose	= 0;	//遮断機の経過時間を元に戻す
			suspend();
		}
		
		//ベースカウンター
		if(i++ == 18500)
		{
			j++;
			k++;
			i	= 0;
			if(timeOfClose	< 20)	timeOfClose++;

		}
		//警報音開始を設定
		if(j == 3)
		{
			DirVolume	= 1;
			j = 0;
		}
		//警報灯の点滅
		if(k ==4)
		{
			if((PORTD & 0x80) == 0x80)//一瞬だけ両方の警報灯を光らせる
				PORTB &= 0xfe;
			else
				PORTD |= 0x80;
		}
		if(k ==8)
		{
			if((PORTB & 0x01) == 0x01)//一瞬だけ両方の警報灯を光らせる
			{
				PORTD &= 0x7f;
				k	= 0;
			}
			else
				PORTB |= 0x01;
		}
		//遮断機の降下
		if(timeOfClose	== 20)
		{
			PORTD &= ~_BV(PD5);
			PORTD |= _BV(PD6);
			//OCR0A	= 0xe8;
			timeOfClose	= 21;
		}
	}

	return 0;
}

int suspend( void )
{
	
	cli();		//割込を不許可にして消音する。
	
	//遮断機を下げる信号を停止
	PORTD &= ~_BV(PD6);
	//OCR0A	= 0x00;
	
	//警報灯を消灯する
	PORTB |= _BV(PB0);
	PORTD |= _BV(PD7);
	
	_delay_ms(400);	//チャタリング対策で時間待ち
	
	PORTD |= 0x20;	//遮断機を上げる
	
	//スピーカーを止める
	OCR2B	= 0;

	while((PIND & 0x01) == 0)
	//while(1)
	{
	}
	_delay_ms(200);		//チャタリング対策で時間待ち	
	PORTD &= ~_BV(PD5);	//遮断機の降下信号を停止
	sei();
	return 0;
}